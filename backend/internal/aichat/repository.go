//go:build ignore
// +build ignore

package aichat

/*
Legacy placeholder file intentionally excluded from build.
Actual implementation lives in repository_impl.go.











































































































































}    return m, nil    _, _ = r.db.ExecContext(ctx, `UPDATE ai_chat_threads SET updated_at = now() WHERE id = $1`, threadID)    }        m.ProjectInfo = storedProjectInfo    if len(storedProjectInfo) > 0 && string(storedProjectInfo) != "null" {    }        return Message{}, err    if err != nil {    ).Scan(&m.ID, &m.ThreadID, &m.Sender, &m.Text, &storedProjectInfo, &m.CreatedAt)        projectInfo,        text,        sender,        threadID,         RETURNING id, thread_id, sender, text, project_info, created_at`,         VALUES ($1, $2, $3, $4::jsonb)        `INSERT INTO ai_chat_messages (thread_id, sender, text, project_info)        ctx,    err = r.db.QueryRowContext(    var storedProjectInfo []byte    var m Message    }        projectInfo = json.RawMessage("null")    if len(projectInfo) == 0 {    }        text = "..."    if text == "" {    text = strings.TrimSpace(text)    sender = normalizeSender(sender)    }        return Message{}, err    if err != nil {    threadID, err := r.ensureThread(ctx, userID, mode)func (r *Repository) AppendMessage(ctx context.Context, userID uuid.UUID, mode, sender, text string, projectInfo json.RawMessage) (Message, error) {}    return messages, rows.Err()    }        messages = append(messages, m)        }            m.ProjectInfo = projectInfo        if len(projectInfo) > 0 && string(projectInfo) != "null" {        }            return nil, err        if err := rows.Scan(&m.ID, &m.ThreadID, &m.Sender, &m.Text, &projectInfo, &m.CreatedAt); err != nil {        var projectInfo []byte        var m Message    for rows.Next() {    messages := make([]Message, 0)    defer rows.Close()    }        return nil, err    if err != nil {    )        threadID,         ORDER BY created_at ASC`,         WHERE thread_id = $1         FROM ai_chat_messages        `SELECT id, thread_id, sender, text, project_info, created_at        ctx,    rows, err := r.db.QueryContext(    }        return nil, err    if err != nil {    threadID, err := r.ensureThread(ctx, userID, mode)func (r *Repository) ListMessages(ctx context.Context, userID uuid.UUID, mode string) ([]Message, error) {}    return id, nil    }        return uuid.Nil, err    if err != nil {    ).Scan(&id)        mode,        userID,         RETURNING id`,         DO UPDATE SET updated_at = now()         ON CONFLICT (user_id, mode)         VALUES ($1, $2)        `INSERT INTO ai_chat_threads (user_id, mode)        ctx,    err := r.db.QueryRowContext(    var id uuid.UUID    mode = normalizeMode(mode)func (r *Repository) ensureThread(ctx context.Context, userID uuid.UUID, mode string) (uuid.UUID, error) {}    }        return "other"    default:        return value    case "user", "other":    switch value {    value := strings.ToLower(strings.TrimSpace(sender))func normalizeSender(sender string) string {}    }        return "template"    default:        return value    case "template", "ordinary":    switch value {    value := strings.ToLower(strings.TrimSpace(mode))func normalizeMode(mode string) string {}    CreatedAt   time.Time       `json:"createdAt"`    ProjectInfo json.RawMessage `json:"projectInfo,omitempty"`    Text        string          `json:"text"`    Sender      string          `json:"sender"`    ThreadID    uuid.UUID       `json:"thread_id"`    ID          uuid.UUID       `json:"id"`type Message struct {}    return &Repository{db: db}func NewRepository(db *sql.DB) *Repository {}    db *sql.DBtype Repository struct {)    "github.com/google/uuid"    "time"    "strings"
*/
