//go:build ignore
// +build ignore

package zhcp
package zhcp

import (
	"bytes"
	"context"





















































































































































































































































}	return u.String(), nil	u.Path = path.Join(u.Path, p)	}		return "", err	if err != nil {	u, err := url.Parse(c.baseURL)func (c *Client) joinPath(p string) (string, error) {}	return &payload, nil	}		return nil, fmt.Errorf("parser returned empty project structure")	if payload.ProjectStructure == nil {	}		return nil, fmt.Errorf("parser returned unsuccessful result")		}			return nil, fmt.Errorf("parser returned unsuccessful result: %s", payload.Error.Message)		if payload.Error != nil && strings.TrimSpace(payload.Error.Message) != "" {	if !payload.Success {	}		return nil, err	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {	var payload ParseResultResponse	}		return nil, fmt.Errorf("parser result failed: %s", strings.TrimSpace(string(raw)))		raw, _ := io.ReadAll(resp.Body)	if resp.StatusCode < 200 || resp.StatusCode > 299 {	defer resp.Body.Close()	}		return nil, err	if err != nil {	resp, err := c.httpClient.Do(req)	}		return nil, err	if err != nil {	req, err := http.NewRequestWithContext(ctx, http.MethodGet, endpoint, nil)	}		return nil, err	if err != nil {	endpoint, err := c.joinPath("/api/parse/result/" + jobID)func (c *Client) fetchResult(ctx context.Context, jobID string) (*ParseResultResponse, error) {}	return &payload, nil	}		return nil, err	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {	var payload parseStatusResponse	}		return nil, fmt.Errorf("parser status failed: %s", strings.TrimSpace(string(raw)))		raw, _ := io.ReadAll(resp.Body)	if resp.StatusCode < 200 || resp.StatusCode > 299 {	defer resp.Body.Close()	}		return nil, err	if err != nil {	resp, err := c.httpClient.Do(req)	}		return nil, err	if err != nil {	req, err := http.NewRequestWithContext(ctx, http.MethodGet, endpoint, nil)	}		return nil, err	if err != nil {	endpoint, err := c.joinPath("/api/parse/status/" + jobID)func (c *Client) fetchStatus(ctx context.Context, jobID string) (*parseStatusResponse, error) {}	}		}		case <-ticker.C:			return ctx.Err()		case <-ctx.Done():		select {		}			return fmt.Errorf("parser failed")			}				return fmt.Errorf("parser failed: %s", status.Error)			if status.Error != "" {		case "failed":			return nil		case "completed":		switch strings.ToLower(status.Status) {		}			return err		if err != nil {		status, err := c.fetchStatus(ctx, jobID)	for {	defer ticker.Stop()	ticker := time.NewTicker(2 * time.Second)func (c *Client) waitForCompletion(ctx context.Context, jobID string) error {}	return payload.JobID, nil	}		return "", fmt.Errorf("parser upload returned empty job id")	if strings.TrimSpace(payload.JobID) == "" {	}		return "", err	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {	var payload parseUploadResponse	}		return "", fmt.Errorf("parser upload failed: %s", strings.TrimSpace(string(raw)))		raw, _ := io.ReadAll(resp.Body)	if resp.StatusCode < 200 || resp.StatusCode > 299 {	defer resp.Body.Close()	}		return "", err	if err != nil {	resp, err := c.httpClient.Do(req)	req.Header.Set("Content-Type", writer.FormDataContentType())	}		return "", err	if err != nil {	req, err := http.NewRequestWithContext(ctx, http.MethodPost, endpoint, &body)	}		return "", err	if err != nil {	endpoint, err := c.joinPath("/api/parse/upload")	}		return "", err	if err := writer.Close(); err != nil {	}		_ = writer.WriteField("content_type", contentType)	if contentType != "" {	}		return "", err	if _, err := part.Write(data); err != nil {	}		return "", err	if err != nil {	part, err := writer.CreateFormFile("file", filename)	writer := multipart.NewWriter(&body)	var body bytes.Bufferfunc (c *Client) upload(ctx context.Context, filename string, contentType string, data []byte) (string, error) {}	return c.fetchResult(ctx, jobID)	}		return nil, err	if err := c.waitForCompletion(ctx, jobID); err != nil {	}		return nil, err	if err != nil {	jobID, err := c.upload(ctx, filename, contentType, data)func (c *Client) ParseDocument(ctx context.Context, filename string, contentType string, data []byte) (*ParseResultResponse, error) {}	EndDate   string `json:"end_date"`	StartDate string `json:"start_date"`	Status    string `json:"status"`	Name      string `json:"name"`type ParsedTask struct {}	Tasks     []ParsedTask `json:"tasks"`	EndDate   string      `json:"end_date"`	StartDate string      `json:"start_date"`	Name      string      `json:"name"`type ParsedPhase struct {}	Phases      []ParsedPhase `json:"phases"`	Deadline    string       `json:"deadline"`	Description string       `json:"description"`	Title       string       `json:"title"`type ParsedProject struct {}	Project ParsedProject `json:"project"`type ProjectStructure struct {}	Message string `json:"message"`type ParserError struct {}	Error            *ParserError     `json:"error"`	ProjectStructure *ProjectStructure `json:"project_structure"`	Success          bool             `json:"success"`type ParseResultResponse struct {}	Error    string `json:"error"`	Progress int    `json:"progress"`	Status   string `json:"status"`	JobID    string `json:"jobId"`type parseStatusResponse struct {}	Status string `json:"status"`	JobID  string `json:"jobId"`type parseUploadResponse struct {}	}		},			Timeout: 45 * time.Second,		httpClient: &http.Client{		baseURL: trimmed,	return &Client{	}		trimmed = "http://localhost:8081"	if trimmed == "" {	trimmed := strings.TrimRight(strings.TrimSpace(baseURL), "/")func NewClient(baseURL string) *Client {}	httpClient *http.Client	baseURL    stringtype Client struct {)	"time"	"strings"	"path"	"net/url"	"net/http"	"mime/multipart"	"io"	"fmt"	"encoding/json"